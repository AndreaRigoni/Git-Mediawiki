#! /usr/bin/perl

use strict;
use MediaWiki::API;
use Storable qw(freeze thaw);
use DateTime::Format::ISO8601;
use Encode qw(encode_utf8);

# Mediawiki filenames can contain forward slashes. This variable decides by which pattern they should be replaced
my $slash_replacement = "<slash>";

my $remotename = $ARGV[0];
my $url = $ARGV[1];

print STDERR "$url\n";

# commands parser
my $entry;
my @cmd;
while (1) {
	$| = 1; #flush STDOUT
	$entry = <STDIN>;
	print STDERR $entry;
	chomp($entry);
	@cmd = undef;
	@cmd = split(/ /,$entry);
	if ($cmd[0] eq "capabilities") {
		last unless ($cmd[1] eq "");
		mw_capabilities();
	} elsif ($cmd[0] eq "list") {
		last unless ($cmd[2] eq "");
		mw_list($cmd[1]);
	} elsif ($cmd[0] eq "import") {
		last unless ($cmd[1] ne "" && $cmd[2] eq "");
		mw_import();
	} elsif ($cmd[0] eq "option") {
		last unless ($cmd[1] ne "" && $cmd[2] ne "" && $cmd[3] eq "");
		mw_option($cmd[1],$cmd[2]);
	} elsif ($cmd[0] eq "push") {
		# Check the pattern <src>:<dst>
		my @pushargs = split(/:/,$cmd[1]);
		last unless ($pushargs[1] ne "" && $pushargs[2] eq "");
		mw_push($pushargs[0],$pushargs[1]);
	} elsif ($cmd[0] eq "") {
		# End of input
		last;
	} else {
		print STDERR "Unknown capability. Aborting...\n";
		last;
	}
}

########################## Functions ##############################

sub get_last_local_revision {
	# Get last commit sha1
	my $commit_sha1 = `git rev-parse refs/mediawiki/$remotename/master 2>/dev/null`;

	# Get note regarding that commit
	chomp($commit_sha1);
	my $note = `git log --notes=mediawiki 2>/dev/null | grep "mediawiki_revision: " | sed -n 1p`;
	$note =~ s/^\s+//; #left trim of note 
	my @note_info = split(/ /, $note);

	my $lastrevision_number;
	if (!($note_info[0] eq "mediawiki_revision:")) {
		print STDERR "No previous mediawiki revision found";
		$lastrevision_number = 0;
	} else {
		# Notes are formatted : mediawiki_revision: #number
		$lastrevision_number = $note_info[1];
		chomp($lastrevision_number);
		print STDERR "Last local mediawiki revision found is $lastrevision_number ";
	}
	return $lastrevision_number;
}

sub get_last_remote_revision {
	my $mediawiki = MediaWiki::API->new;
	$mediawiki->{config}->{api_url} = "$url/api.php";

	my $pages = $mediawiki->list({
		action => 'query',
		list => 'allpages',
		aplimit => 500,
	});

	my $max_rev_num = 0;

	foreach my $page (@$pages) {
		my $id = $page->{pageid};


		my $query = {
			action => 'query',
			prop => 'revisions',
			rvprop => 'ids',
			pageids => $id,
		};

		my $result = $mediawiki->api($query);
		
		my $lastrev = pop(@{$result->{query}->{pages}->{$id}->{revisions}});
		
		$max_rev_num = ($lastrev->{revid} > $max_rev_num ? $lastrev->{revid} : $max_rev_num);
	}

	print STDERR "Last remote revision found is $max_rev_num\n";
	return $max_rev_num;
}

sub literal_data {
	my ($content) = @_;
	print "data ", bytes::length($content), "\n", $content;
}

sub mw_capabilities {
	# Revisions are imported to the private namespace
	# refs/mediawiki/$remotename/ by the helper and fetched into
	# refs/remotes/$remotename later by fetch.
	print STDOUT "refspec refs/heads/*:refs/mediawiki/$remotename/*\n";
	print STDOUT "import\n";
	print STDOUT "list\n";
	print STDOUT "option\n";
	print STDOUT "push\n";
	print STDOUT "\n";
}

sub mw_list {
	# MediaWiki do not have branches, we consider one branch arbitrarily
	# called master
	print STDOUT "? refs/heads/master\n";
	print STDOUT '@'."refs/heads/master HEAD\n";
	print STDOUT "\n";

}

sub mw_option {
	print STDERR "not yet implemented \n";
	print STDOUT "unsupported\n";
}

sub mw_import {
	my @wiki_name = split(/:\/\//,$url);
	my $wiki_name = $wiki_name[1];

	my $mediawiki = MediaWiki::API->new;
	$mediawiki->{config}->{api_url} = "$url/api.php";

	my $pages = $mediawiki->list({
		action => 'query',
		list => 'allpages',
		aplimit => 500,
	});
	if ($pages == undef) {
		print STDERR "fatal: '$url' does not appear to be a mediawiki\n";
		exit;
	}

	my @revisions;
	print STDERR "Searching revisions...\n";
	my $fetch_from = get_last_local_revision() + 1;
	if ($fetch_from == 1) {
		print STDERR ", fetching from beginning\n";
	} else {
		print STDERR ", fetching from here\n";
	}
	my $n = 1;
	foreach my $page (@$pages) {
		my $id = $page->{pageid};

		print STDERR "$n/", scalar(@$pages), ": ". encode_utf8($page->{title})."\n";
		$n++;

		my $query = {
			action => 'query',
			prop => 'revisions',
			rvprop => 'ids',
			rvdir => 'newer',
			rvstartid => $fetch_from,
			rvlimit => 500,
			pageids => $page->{pageid},
		};

		my $revnum = 0;
		# Get 500 revisions at a time due to the mediawiki api limit
		while (1) {
			my $result = $mediawiki->api($query);

			# Parse each of those 500 revisions
			foreach my $revision (@{$result->{query}->{pages}->{$id}->{revisions}}) {
				my $page_rev_ids;
				$page_rev_ids->{pageid} = $page->{pageid};
				$page_rev_ids->{revid} = $revision->{revid};
				push (@revisions, $page_rev_ids);
				$revnum++;
			}
			last unless $result->{'query-continue'};
			$query->{rvstartid} = $result->{'query-continue'}->{revisions}->{rvstartid};
		}
		print STDERR "  Found ", $revnum, " revision(s).\n";
	}

	# Creation of the fast-import stream
	print STDERR "Fetching & writing export data...\n";
	binmode STDOUT, ':binary';
	$n = 0;

	foreach my $pagerevids (sort {$a->{revid} <=> $b->{revid}} @revisions) {
		#fetch the content of the pages
		my $query = {
			action => 'query',
			prop => 'revisions',
			rvprop => 'content|timestamp|comment|user|ids',
			revids => $pagerevids->{revid},
		};

		my $result = $mediawiki->api($query);

		my $rev = pop(@{$result->{query}->{pages}->{$pagerevids->{pageid}}->{revisions}});

		$n++;
		my $user = $rev->{user} || 'Anonymous';
		my $dt = DateTime::Format::ISO8601->parse_datetime($rev->{timestamp});

		my $comment = defined $rev->{comment} ? $rev->{comment} : '*Empty MediaWiki Message*';
		my $title = encode_utf8($result->{query}->{pages}->{$pagerevids->{pageid}}->{title});
		my $content = $rev->{'*'};
		# This \n is important. If it's not added, a conflict is going to happen if you change
		# the last line of a file, push it and then pull it back from mediawiki.
		# Note : it seems like there are still problems with this. To be investigated further
		$content .= "\n"; 
		
		$title =~ y/ /_/;
		$title =~ s/\//$slash_replacement/g;

		print STDERR "$n/", scalar(@revisions), ": Revision nÂ°$pagerevids->{revid} of $title\n";

		print "commit refs/mediawiki/$remotename/master\n";
		print "mark :$n\n";
		print "committer $user <$user\@$wiki_name> ", $dt->epoch, " +0000\n";
		literal_data(encode_utf8($comment));
		# If it's not a clone, needs to know where to start from
		if ($fetch_from != 1 && $n == 1) {
			print "from refs/mediawiki/$remotename/master^0\n";
		}
		print "M 644 inline $title.mw\n";
		literal_data(encode_utf8($content));
		print "\n\n";


		# mediawiki revision number in the git note
		if ($fetch_from == 1 && $n == 1) {
			print "reset refs/notes/mediawiki\n";
		}
		print "commit refs/notes/mediawiki\n";
		print "committer $user <$user\@$wiki_name> ", $dt->epoch, " +0000\n";
		literal_data(encode_utf8("note added by git-mediawiki"));
		if ($fetch_from != 1 && $n == 1) {
			print "from refs/notes/mediawiki^0\n";
		}
		print "N inline :$n\n";
		literal_data(encode_utf8("mediawiki_revision: " . $pagerevids->{revid}));
		print "\n\n";
	}

	if ($fetch_from == 1) {
		if ($n != 0) {
			print "reset $_[0]\n"; #$_[0] contains refs/heads/master
			print "from :$n\n";
		} else {
			print STDERR "You appear to have cloned an empty mediawiki\n";
			#What do we have to do here ? If nothing is done, an error is thrown saying that
			#HEAD is refering to unknown object 0000000000000000000
		}
	}

}

sub mw_push {

	sub push_file {
		#$_[0] contains a string in this format : 
		#:100644 100644 <sha1_of_blob_before_commit> <sha1_of_blob_now> <status> <filename.mw>
		#$_[1] contains the title of the commit message (the only phrase kept in the revision message)
		my @blob_info_split = split(/ |\t/, $_[0]);

		my $sha1 = $blob_info_split[3];
		my $complete_file_name = $blob_info_split[5];

		my @complete_file_name_split = split(/\./, $complete_file_name);
		if ($complete_file_name_split[1] eq "mw"){
			my $title = $complete_file_name_split[0];
			$title =~ s/$slash_replacement/\//g;
			my $file_content = `git cat-file -p $sha1`;
			chomp($file_content);

			my $mw = MediaWiki::API->new();
			$mw->{config}->{api_url} = "$url/api.php";

			# log in to the wiki
			#$mw->login( { lgname => 'ilapa', lgpassword => 'kiplaki' } ) || die $mw->{error}->{code} . ': ' . $mw->{error}->{details};
			$mw->edit( {
				action => 'edit',
				summary => $_[1], 
				title => encode_utf8($title),
				text => encode_utf8($file_content),
			});

			print STDERR "Pushed file : $sha1 - $title\n";
		} else {
			print STDERR "$complete_file_name not a mediawiki file. '(Not pushable on this version)\n"
		}
	}
	
	# Get sha1 of commit pointed by local HEAD
	# Get sha1 of commit pointed by remotes/origin/master
	# If they are equal : "Already up to date"
	# Else
		# For each commit in between those two, including the one pointed by HEAD and in chronological order
			# Get files related to this commit
			# Push this file
		# End for each
	# endif

	my $last_local_revid = get_last_local_revision();
	my $last_remote_revid = get_last_remote_revision();

	my $HEAD_sha1 = `git rev-parse $_[0] 2>/dev/null`; chomp($HEAD_sha1);
	my $remoteorigin_sha1 = `git rev-parse refs/remotes/origin/master 2>/dev/null`; chomp($remoteorigin_sha1);

	if ($last_local_revid < $last_remote_revid){
		my $message = "\"To prevent you from losing history, non-fast-forward updates were rejected \\n";
		$message .= "Merge the remote changes (e.g. 'git pull') before pushing again. See the";
		$message .= " 'Note about fast-forwards' section of 'git push --help' for details.\"";
		print "error $_[0] $message\n";
	} elsif ($HEAD_sha1 ne $remoteorigin_sha1) {
		# Get every commit in between HEAD and refs/remotes/origin/master,
		# including HEAD and refs/remotes/origin/master
		my $parsed_sha1 = $remoteorigin_sha1;
		while ($parsed_sha1 ne $HEAD_sha1) {
			my $commit_info =  `git rev-list --children $_[0] | grep -e "^$parsed_sha1"`;
			my @commit_info_split = split(/ |\n/, $commit_info);
			# $commit_info_split[0] is the sha1 of the commit itself
			# $commit_info_split[1] is the sha1 of its direct child
			my $blob_infos = `git diff --raw --abbrev=40 $commit_info_split[0] $commit_info_split[1]`;
			my @blob_info_list = split(/\n/, $blob_infos);
			my $commit_msg = `git show --pretty=format:"%s" $commit_info_split[1] | sed -n 1p`;
			chomp($commit_msg);
			foreach my $blob_info (@blob_info_list) {
				push_file($blob_info, $commit_msg);
			}		
			$parsed_sha1 = $commit_info_split[1];
		}

		print "ok $_[1]\n";

		# Pulling from mediawiki after pushing in order to keep things synchronized
		#exec("git pull >/dev/null");
	}
	print "\n";
}
